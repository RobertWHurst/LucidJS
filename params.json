{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"LucidJS","body":"#LucidJS\r\n\r\n##Decouple components, make them lucid.\r\n\r\nLucidJS is a library that allows you to make your own event emitters with ease.\r\nIts fully featured and works with plain old script tags, AMD module loaders, or even as a nodeJS module.\r\n\r\n##Examples\r\n\r\n###Simple Factory Functions\r\n\r\nIn this example shows off one of the more simple emitter patterns. This is ment to give you a glimps into \r\nhow you can use emitters in your projects.\r\n\r\n\t//we create a dog, Spot, and two puppies, Dot and Chip.\r\n\tvar spot = Dog('Spot');\r\n\tvar dot = Puppy('Dot', spot);\r\n\tvar chip = Puppy('Chip', spot);\r\n\t\r\n\t//we make Spot bark, the puppies copies Spot.\r\n\tspot.bark();\r\n\t>> 'Spot: woof! woof!'\r\n\t>> 'Dot: yip! yip!'\r\n\t>> 'Chip: yip! yip!'\r\n\t\r\n\t//The dog factory\r\n\tfunction Dog(name) {\r\n\t\r\n\t\t//create the return object/emitter\r\n\t\tvar dog = LucidJS.emitter();\r\n\t\t\r\n\t\t//attach the name and bark method\r\n\t\tdog.name = name;\r\n\t\tdog.bark = bark;\r\n\t\t\r\n\t\t//return the object/emitter\r\n\t\treturn dog;\r\n\t\t\r\n\t\t//makes the dog bark\r\n\t\tfunction bark() {\r\n\t\t\tdog.trigger('bark');\r\n\t\t\tconsole.log(name + ': woof! woof!');\r\n\t\t}\r\n\t}\r\n\t\r\n\t//The puppy factory\r\n\tfunction Puppy(name, parentDog) {\r\n\t\t\r\n\t\t//create the return object/emitter\r\n\t\tvar puppy = LucidJS.emitter();\r\n\t\t\r\n\t\t//if the parent dog barks the puppy will copy it\r\n\t\tparentDog.on('bark', bark);\r\n\t\t\r\n\t\t//attach the parent dog, the name, and the bark method to the return object/emitter\r\n\t\tpuppy.parent = parentDog;\r\n\t\tpuppy.name = name;\r\n\t\tpuppy.bark = bark;\r\n\t\t\r\n\t\t//return the puppy object\r\n\t\treturn puppy;\r\n\t\t\r\n\t\t//makes the puppy bark\r\n\t\tfunction bark() {\r\n\t\t\tpuppy.trigger('bark');\r\n\t\t\tconsole.log(name + ': yip! yip!');\r\n\t\t}\r\n\t}\r\n\r\n##Method documentation\r\n\r\n\r\n### LucidJS.emitter()\r\n\r\n\t\r\nCreates an event emitter and returns it. If an object is passed in the object is augmented with emitter methods. If a DOM node is passed in it will also be augmented, however any DOM events emitted by the node will also be emitted by the emitter.\r\n\r\n#### Arguments\r\n\r\n\tLucidJS.emitter([object object]) => object emitter\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>object</td>\r\n\t\t\t<td>Optional. Any object or array you wish to turn into an emitter.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\tLucidJS.emitter([object node]) => object emitter\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>node</td>\r\n\t\t\t<td>Optional. Any DOM node you wish to turn into an emitter.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter{}\r\n\r\n\temitter\r\n\t\ton()\r\n\t\tonce()\r\n\t\ttrigger()\r\n\t\tset()\r\n\t\tpipe()\r\n\t\t\tclear()\r\n\t\tlisteners()\r\n\t\t\tclear()\r\n\r\nThe emitter object is produced `LucidJS.emitter`. Any objects passed into `LucidJS.emitter` will have all of the above methods attached. The emitter object contains the API for interacting with the emitter.\r\n\r\n\r\n### emitter.on()\r\n\t\r\nBinds any number of listener callbacks to an event or an array of events. Whenever the given event or events are triggered or set on emitter, the listener callbacks will be executed. Any arguments passed to `trigger()` after the event will be passed into the listener callbacks on execution.\r\n\r\nIf any of the listener callbacks return `false`, the `emitter.trigger` or `emitter.set` that fired the event will return false.\r\nIf the event was from a DOM node and `false` is returned both `event.stopPropigation` and `event.preventDefault` will be called.\r\n\r\n`emitter.on` returns a `binding` object that can be used to modify the event binding.\r\n\r\n#### Arguments\r\n\r\n\temitter.on(string event, function listener[, ...]) => object binding\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that the listener will be bound to.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>listener</td>\r\n\t\t\t<td>A callback function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.on(array events, function listener[, ...]) => object binding\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>events</td>\r\n\t\t\t<td>An array of event names the listener will be bound to.</td>\r\n\t\t\t<td>array</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>listener</td>\r\n\t\t\t<td>A callback function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.once()\r\n\r\nBinds a listener to an event. Acts exactly like `emitter.on` with the exception that once the given event is triggered the binding is automatically cleared. Because of this any listeners bound with `emitter.once` will once fire once.\r\n\r\n`emitter.once` returns a `binding` object that can be used to modify the event binding.\r\n\r\n#### Arguments\r\n\r\n\temitter.once(string event, function listener[, …]) => object binding\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that the listener will be bound to.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>listener</td>\r\n\t\t\t<td>A callback function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.once(array events, function listener[, …]) => object binding\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>events</td>\r\n\t\t\t<td>An array of event names the listener will be bound to.</td>\r\n\t\t\t<td>array</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>listener</td>\r\n\t\t\t<td>A callback function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.trigger()\r\n\r\nTriggers an event or an array of events on the emitter. Any listeners bound with `emitter.on` or `emitter.once` will be executed. Any additional arguments passed into `emitter.trigger` excluding the first argument; the event, will be passed to any and all listeners bound to the emitter.\r\n\r\nIf any listeners triggered explicitly return `false` then `emitter.trigger` will return false as well.\r\n\r\n#### Arguments\r\n\r\n\temitter.trigger(string event, * arg[, ...]) => bool successful\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that will be triggered.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>arg</td>\r\n\t\t\t<td>Any argument to be passed into listeners of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.trigger(array events, * arg[, ...]) => bool successful\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>events</td>\r\n\t\t\t<td>An array of event names that will be triggered.</td>\r\n\t\t\t<td>array</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>arg</td>\r\n\t\t\t<td>Any argument to be passed into listeners of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.set()\r\n\r\nWorks like trigger except that any listeners bound to the event or events after `emitter.set` is called will be fired as soon as they are bound. This is great of events that only happen once such as a `load` event. It prevents your listeners from missing an event because it has already fired prior to binding them.\r\n\r\n#### Arguments\r\n\r\n\temitter.set(string event, * arg[, ...]) => bool successful\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that will be set.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>arg</td>\r\n\t\t\t<td>Any argument to be passed into listeners of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.set(array events, * arg[, ...]) => bool successful\r\n\t\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>events</td>\r\n\t\t\t<td>An array of event names that will be set.</td>\r\n\t\t\t<td>array</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>arg</td>\r\n\t\t\t<td>Any argument to be passed into listeners of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.pipe()\r\n\t\r\nPipes all events or select events from one or more emitters, into another. Any events emitted by the piped emitters will also be emitted by the emitter pipe was called on. This is extremely powerful and allows you to chain your emitters.\r\n\r\nReturns a pipe object that can be used to clear the pipe.\r\n\r\n#### Arguments\r\n\r\n\temitter.pipe(object emitter[, ...]) => object pipe\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>emitter</td>\r\n\t\t\t<td>The emitter that events will be piped from.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.pipe(string event, object emitter[, ...]) => object pipe\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that will be piped.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>emitter</td>\r\n\t\t\t<td>The emitter that events will be piped from.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\temitter.pipe(array events, object emitter[, ...]) => object pipe\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>events</td>\r\n\t\t\t<td>An array of event names that will be piped.</td>\r\n\t\t\t<td>array</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>emitter</td>\r\n\t\t\t<td>The emitter that events will be piped from.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.pipe.clear()\r\n\r\n\temitter.pipe.clear([string event])\r\n\t\r\nAllows clearing all pipes, or pipes that transport select events. If an event name is given, only listeners bound to that event will be cleared. If no event name is given all bound listeners will be cleared.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>Optional. If any pipes are transporting this event they will be cleared.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.listeners()\r\n\r\n\temitter.listeners([string event]) => object eventlisteners\r\n\t\r\nAllows access to the emitter's bound event listeners.\r\n\r\nIf an event name is given, the array of listeners bound to the named event will be returned. If no event name is given then the events will be returned. The events object contains all event arrays.\r\n\r\nDirectly editing the listeners array is not recommended, however it may be necessary to achieve certain types of functionally in specific cases.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>Optional. The name of the event to expose. The listeners bound the the event will be returned.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.listeners.clear()\r\n\r\n\temitter.listeners.clear([string event])\r\n\t\r\nClears listeners bound to the emitter. If an event name is given, only listeners bound to that event will be cleared. If no event name is given all bound listeners will be cleared.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>Optional. The name of the event to clear listeners from.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n##A Foot Note\r\n\r\nIf you like my library feel free to use it however you want. If you wish to contribute to LucidJS please feel free to send me a pull request or make your own fork. Commentary is welcome on any of my projects.\r\n\r\nCheers and happy coding.\r\n\r\n","google":"UA-8963518-4","tagline":"LucidJS is a chainable event emitter library. It offers several unique features such as set events, emitter piping, DOM node encapsulation, sub events, along with the usual event triggering and binding. LucidJS emitters also feature meta events that allow listening for event binding and event triggering."}