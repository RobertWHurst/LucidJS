{"google":"UA-8963518-4","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"#LucidJS\r\n\r\n##Decouple components, make them lucid.\r\n\r\nLucidJS is a small library that allows you to make your own event emitters with ease.\r\nIts fully featured and works with a plain old script tag, AMD module loaders, and nodeJS.\r\n\r\nLucidJS is simple and easy to use. Its also remarkably useful and carries an 'ace' called\r\n`pipe`.\r\n\r\n\r\n##Hello World\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\r\n\temitter.on('helloWorld', function() {\r\n\t\talert('Hello World!');\r\n\t}\r\n\r\n\temitter.trigger('helloWorld');\r\n\r\nIn this simple example we create an emitter with `LucidJS.emitter` then bind to an event\r\ncalled `'helloWorld'`. Our event handler fires and alert with the string `'Hello World!'`.\r\n\r\nThis is uber simple and doesn't show off all of the fexablity of LucidJS. Its just ment to\r\nshowcase the simplicity.\r\n\r\n\r\n##Message Passing\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\r\n\temitter.on('message', function(message) {\r\n\t\talert(message);\r\n\t}\r\n\r\n\temitter.trigger('message', 'Hi there, this is a message.');\r\n\r\nIn this example you can see that `trigger` accepts both the event type and a message. Actually\r\nTrigger will take anything and any number of arguments after the event name and pass them to the\r\nbound handlers.\r\n\r\nYou can do crazy things like this:\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\r\n\temitter.on('message', function(hander, message, times) {\r\n\t\thander(message, times);\r\n\t}\r\n\r\n\temitter.trigger('message', function(message, times) {\r\n\t\tfor(var i = 0; i < times; i += 1) {\r\n\t\t\talert(message + ' ' + (i + 1) + '.');\r\n\t\t}\r\n\t}, 'Hi there, this is message', 100);\r\n\r\n\t//There that will teach you to copy and paste!\r\n\r\nAs you can see LucidJS emitters are very flexible and will get right out of your way (unlike alert boxes...).\r\n\r\n\r\n##The Ace\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\r\n\tvar otherEmitter = LucidJS.emitter();\r\n\tvar domNode = document.createElement('div');\r\n\tvar jQueryElement = $('<div></div>');\r\n\r\n\temitter.pipe(otherEmitter);\r\n\temitter.pipe(domNode);\r\n\r\n\temitter.on('click', function() {\r\n\t\talert(\"a 'click' event from 'otherEmitter', 'domNode', 'jQueryElement' can trigger this message.\");\r\n\t});\r\n\r\n\t//even jQuery wrapped elements\r\n\temitter.pipe(jQueryElement);\r\n\r\nIn the Intro I told you LucidJS carried and 'ace' called `pipe`. Above you can see what I mean. You can pipe events in from any other event emitter object supported. Currently `pipe` supports other LucidJS emitters, DOM objects (addEventListener or attachEvent), and even jQuery elements.\r\n\r\n\r\n##Set an event in stone\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\t\r\n\temitter.on('ready', function() {\r\n\t\t//will fire\r\n\t});\r\n\t\r\n\temitter.set('ready');\r\n\t\r\n\tsetTimeout(function() {\r\n\t\temitter.on('ready', function() {\r\n\t\t\t//will fire instantly after 2000ms\r\n\t\t});\r\n\t}, 2000);\r\n\t\r\nIn some cases you only want to trigger an event once but you may want anything bound to the event later to be triggered automatically. This is what `emitter.set` does.\r\n\r\n\r\n##Get all of the listeners\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\t\r\n\temitter.on('cake', function() { alert('CAKE!!!'); });\r\n\t\r\n\tvar cakeListeners = emitter.listeners('cake');\r\n\t// cakeListeners >>> [ function() { alert('CAKE!!!'); } ]\r\n\t\r\n\tvar allListeners = emitter.listeners();\r\n\t// allListeners >>> {\"cake\": [ function() { alert('CAKE!!!'); } ] }\r\n\t\r\nIf you ever want to get all of the listeners on an event or event the hole emitter you can do so with `emitter.listeners()`. Editing the arrays returned will allow you to directly edit the emitter.\r\n\r\n\r\n##Cleaning up\r\n\r\n\tvar emitter = LucidJS.emitter();\r\n\tvar otherEmitter = LucidJS.emitter();\r\n\r\n\tvar pipe = emitter.pipe(otherEmitter);\r\n\r\n\temitter.on('pipedEvent', function() {\r\n\t\talert('I will never be fired');\r\n\t});\r\n\tvar bind = emitter.on('triggeredEvent', function() {\r\n\t\talert('I also will never be fired');\r\n\t});\r\n\r\n\tpipe.clear();\r\n\tbind.clear();\r\n\r\n\totherEmitter.trigger('pipedEvent');\r\n\temitter.trigger('triggeredEvent');\r\n\r\nAll of this is great but eventually you may want to stop listening to an event, or stop piping events from another emitter\r\nThis can be done very easily as you can see above.\r\n\r\n\t//clears everything\r\n\temitter.listeners.clear();\r\n\t\r\n\t//clears just the listeners on the 'cake' event\r\n\temitter.listeners.clear('cake');\r\n\r\nAnd you can also clear all listener callbacks on a single event or the hole emitter in one clean swoop as above.\r\n\r\n\r\n##Whats the point?\r\n\r\n\tfunction Dog(name) {\r\n\t\tvar dog;\r\n\t\t\r\n\t\t//create the dog api\r\n\t\t dog = {\r\n\t\t\t\"bark\": bark,\r\n\t\t\t\"rollOver\": rollOver,\r\n\t\t\t\"walk\": walk\r\n\t\t};\r\n\t\t\r\n\t\t//attach the emitter\r\n\t\tLucidJS.emitter(dog);\r\n\t\t\r\n\t\treturn dog;\r\n\t\t\r\n\t\tfunction bark() {\r\n\t\t\tvar message = 'Woof! Woof!';\r\n\t\t\temitter.trigger(message);\r\n\t\t\talert(message);\r\n\t\t}\r\n\t\tfunction rollOver() {\r\n\t\t\tvar message = name + ' rolled over!';\r\n\t\t\temitter.trigger('rollOver', message);\r\n\t\t\talert(message);\r\n\t\t}\r\n\t\tfunction walk() {\r\n\t\t\tvar message = name + ' went for a walk';\r\n\t\t\temitter.trigger('walk', message);\r\n\t\t\talert(message);\r\n\t\t}\r\n\t}\r\n\r\nThis example of a 'Dog' class shows one way to use LucidJS as a event emitter for your own objects. In this case the\r\nreturned dog object contains the api for the dog instance. Its then passed to `LucidJS.emitter()` and turned into an emitter  allowing external code to listen for the dog's 'walk', 'rollOver', and 'bark' events.\r\n\r\n\r\n##Method documentation\r\n\r\n\r\n### LucidJS.emitter()\r\n\r\n\tLucidJS.emitter([object object]) => object emitter\r\n\t\r\nCreates an event emitter and returns it. If an object is passed in the object is augmented with emitter methods.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>object</td>\r\n\t\t\t<td>Optional. Any object or array you wish to turn into an emitter.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter{}\r\n\r\n\temitter => {\r\n\t\t\"on\": on()\r\n\t\t\"once\": once()\r\n\t\t\"trigger\": trigger()\r\n\t\t\"set\": set()\r\n\t\t\"pipe\": pipe()\r\n\t\t\"listeners\": listeners() => {\r\n\t\t\t\"clear\": clear()\r\n\t\t}\r\n\t}\r\n\r\nThe emitter object is produced `LucidJS.emitter`. Any objects passed into `LucidJS.emitter` will have all of the above methods attached. The emitter object contains the API for interacting with the emitter.\r\n\r\n\r\n### emitter.on()\r\n\r\n\temitter.on(string event, function handler) => object binding\r\n\t\r\nBinds a handler to an event. Whenever the given event is triggered or set on emitter, the handler will be executed. Any additional arguments passed to `trigger()` will be passed into the handler on execution.\r\n\r\nIf the handler returns `false`, it will cause the source of the event; `emitter.trigger` or `emitter.set` to return false.\r\n\r\n`emitter.on` returns a `binding` object that can be used to modify the event binding.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that the handler will be bound to.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>handler</td>\r\n\t\t\t<td>The function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.once()\r\n\r\n\temitter.once(string event, function handler) => object binding\r\n\r\nBinds a handler to an event. Acts exactly like `emitter.on` with the execption that once the given event is triggered the binding is automatically cleared. Because of this any handlers bound with `emitter.once` will once fire once.\r\n\r\nIf the handler returns `false`, it will cause the source of the event; `emitter.trigger` or `emitter.set` to return false.\r\n\r\n`emitter.once` returns a `binding` object that can be used to modify the event binding.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that the handler will be bound to.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>handler</td>\r\n\t\t\t<td>The function that will be executed whenever the event given is triggered.</td>\r\n\t\t\t<td>function</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.trigger()\r\n\r\n\temitter.trigger(string event, * args...) => bool successful\r\n\r\nTriggers an event on the emitter. Any handlers bound with `emitter.on` or `emitter.once` will be executed. Any additional arguments passed into `emitter.trigger` excluding the first argument; the event, will be passed to any and all handlers bound to the emitter.\r\n\r\nIf any of the handlers returned `false\t` then `emitter.trigger` will return false. Otherwise it will return true.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that will be triggered.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>...args</td>\r\n\t\t\t<td>Any additional arguments that will be passed to the handers of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.set()\r\n\r\n\temitter.set(string event, * args...) => bool successful\r\n\r\nTriggers an event on the emitter. Useful for flagging, `emitter.set` acts like `emitter.trigger` but instead of just executing bound handlers, it executes both bound handlers and all future handlers. Adittionally, all handlers bound to a set event are cleared after they are executed to prevent them from executing again.\r\n\r\nIf any of the handlers returned `false\t` then `emitter.set` will return false. Otherwise it will return true.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>The name of the event that will be set.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>...args</td>\r\n\t\t\t<td>Any additional arguments that will be passed to the handers of the event.</td>\r\n\t\t\t<td>*</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.pipe()\r\n\r\n\temitter.pipe(object emitter) => object pipe\r\n\t\r\nPipes all events from a source emitter into the emitter. Any events triggered or set on the source emitter will be triggered or set on the piping emitter aswell.\r\n\r\nReturns a pipe object that can be used to modify the pipe.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>emitter</td>\r\n\t\t\t<td>The emitter that events will be piped from.</td>\r\n\t\t\t<td>object</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.listeners()\r\n\r\n\temitter.listeners([string event]) => object eventHandlers\r\n\t\r\nAllows access to the emitter's bound event handlers.\r\n\r\nIf an event name is given, the array of handlers bound to the named event will be returned. If no event name is given then the events will be returned. The events object contains all event arrays.\r\n\r\nDirectly editting the handlers array is not recommended, however it may be nessisary to achieve curtain types of functionally in specific cases.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>Optional. The name of the event to expose. The handlers bound the the event will be returned.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n### emitter.listeners.clear()\r\n\r\n\temitter.listeners.clear([string event])\r\n\t\r\nClears handlers bound to the emitter. If an event name is given, only handlers bound to that event will be cleared. If no event name is given all bound handlers will be cleared.\r\n\r\n#### Arguments\r\n\r\n<table>\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Name</th>\r\n\t\t\t<th>Description</th>\r\n\t\t\t<th>Allowed Types</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>event</td>\r\n\t\t\t<td>Optional. The name of the event to clear handlers from.</td>\r\n\t\t\t<td>string</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n\r\n\r\n##A Foot Note\r\nIf you like my library feel free to use it however you want. If you wish to contribute to LucidJS please feel free to send me a pull request or make your own fork. Commentary is welcome on any of my projects.\r\n\r\nCheers and happy coding.\r\n","name":"LucidJS","tagline":"Lucid is an uber simple and easy to use event emitter library. Lucid allows you to create your own event system and even pipe in events from any number of DOM elements."}